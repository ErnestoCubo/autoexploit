# Contenido


- [Contenido](#contenido)
- [Semanas 1 y 2:](#semanas-1-y-2)
  - [Semana 1](#semana-1)
  - [Semana 2](#semana-2)
- [Semana 3](#semana-3)
- [Semanas 4 y 5](#semanas-4-y-5)
  - [Semana 4](#semana-4)
  - [Semana 5](#Semana-5)
- [Semana 6](#semana-6-y-7)



# Semanas 1 y 2:

Durante estas semanas se ha dado un desrrollo provisional al core.

## Semana 1

Se ha estructurado la forma en la que se deben dividir los módulos de la herramienta, se ha aprovechado a su vez para recoger información sobre herramientas similares como **PSexploit**.

Se ha desarrollado parte del core aunque muy sujeto a cambios, esto se debe a que la estructura principal no debería basarse en setencias condicionales ``` if ``` sino en setencias condicionales ``` switch ```, se han añadido dichas sentencias de tal manera que el script pueda **recibir parametros y evaluarlos**.

Se aporta a continuación código de ``` core.ps1 ```:

```

param(
    [Parameter(Mandatory)][string]$option
)

if ($option -eq "auto") {
        
    Write-Host "Automatic mode selected" -fore Green

}
else{

    if ($option -eq "manual") {
        
        Write-Host "manual mode selected" -fore Green

    }
    else{

        Write-Host -NoNewline "Invalid option usage:" -fore Red
        Write-Host "`n -option help for help `n -option auto for automatic audit `n -option manual for manual audit" -fore Red

    }

}

```



## Semana 2

He decicido cambiar la estructura completa del core para obtener una **mejor legibilidad** del código y evitar la redudancia en el.

Los cambios son los siguientes:

- La estructura mantenida durante la anterior semana se ha cambiado a una con ``` switch ```.
- Se ha añadido un menú de ayuda sin apartar la opción default.
  
Se aporta código nuevo:

```

param(
    [Parameter(Mandatory)][string]$option
)

switch -Wildcard ($option) {
    "auto"{
        Write-Host "Automatic mode selected" -fore Green
            
    }
    "manual"{
        Write-Host "Manual mode selected" -fore Green

        if ($list) {
            Write-Host $list
        }
}
    "help" {
        Write-Host "Help menu `n The options available are auto mode or manual config mode: `n -auto: automatic audit for privESC, it will try to search for plain text creds and files with extra permissions `n -manual: with -list the tool will display a list of the manual exploits, without -list and with -<exploit_name> "   -fore Green
    }
    Default {
        Write-Host -NoNewline "Invalid option usage:" -fore Red
        Write-Host "`n -option help for help `n -option auto for automatic audit `n -option manual for manual audit" -fore Red
            
    }
}

```

# Semana 3

Se ha debugeado el archivo ``` core.ps1 ``` los resultados han sido positvos y se va a pasar a la siguiente fase de desarrollo.

Las proximas semanas se pasará a desarrollar el **módulo automático**, es un cambio a tener en cuenta ya que cambia la planificación de los hitos.


# Semanas 4 y 5

Durante estas dos semanas se ha desarrollado el módulo automático y se han dado pequeños cambios al core.

## Semana 4

Durante la semana se han dado cambios nuevos en el core y se ha empezado a implementar la búsqueda de **ficheros sensibles**, mediante ``` Get-ChildItem ``` y una pequeña lista de directorios con paths a ficheros sensibles.

La estructura nueva de core es la siguiente:
 ```
 param(
    [Parameter(Mandatory)][string]$option
)

function Import-Modules {

    param (
        [Parameter(Mandatory)][string]$module
    )
    
    try {
        Write-Host "[*]Importing modules please wait . . .`n" -ForegroundColor Yellow
        Import-Module -Name (-join((Get-Item .).Fullname, $module)) -Force
        Write-Host  (-join((Get-Item .).Fullname, $module), " module imported") -ForegroundColor Yellow
    }
    catch {
        Write-Host "Error al importar el módulo" -ForegroundColor Red
        Write-Error $_
    }

}

function main {

    param(
        [Parameter(Mandatory)][string]$option,
        [Parameter()][switch]$list = $false
    )

    switch -Wildcard ($option) {
        "auto"{
            Write-Host "Automatic mode selected`n" -ForegroundColor Green
            Import-Modules -module \auto_module.psm1
            Start-Sleep -Seconds 3
            findRecursive
            
        }
        "manual"{
            Write-Host "Manual mode selected" -fore Green

            if ($list) {
                Write-Host $list
            }
    }
        "help" {
            Write-Host "Help menu `n The options available are auto mode or manual config mode: `n -auto: automatic audit for privESC, it will try to search for plain text creds and files with extra permissions `n -manual: with -list the tool will display a list of the manual exploits, without -list and with -<exploit_name> "   -ForegroundColor Green
        }
        Default {
            Write-Host -NoNewline "Invalid option usage:" -ForegroundColor Red
            Write-Host "`n -option help for help `n -option auto for automatic audit `n -option manual for manual audit" -ForegroundColor Red
            
        }
    }

}

main -option $option

```

El módulo automático es el siguiente:

```
New-Module -Name AutoScript -ScriptBlock {
    function findRecursive {
        function searchFile {
            param (
                [Parameter(Mandatory)][string]$file
            )

            try{
                $file = -join("C:\", $file)
                Get-ChildItem -Path $file -ErrorAction stop | Out-Null
                Write-Host (-join($file, " was found")) -ForegroundColor Green
            }
            catch{
                Write-Host (-join($file, " file not found")) -ForegroundColor Red
            }

        }

        $files = @(
            "Windows\repair\sam",
            "Windows\System32\config\RegBack\SAM",
            "Windows\repair\system",
            "Windows\repair\software",
            "Windows\repair\security",
            "Windows\debug\NetSetup.log",
            "Windows\iis5.log",
            "Windows\iis6.log",
            "Windows\iis7.log",
            "Windows\system32\logfiles\httperr\httperr1.log",
            "Windows\Panther\Unattended.xml",
            "Windows\system32\config\AppEvent.Evt",
            "Windows\system32\config\SecEvent.Evt",
            "Windows\system32\config\default.sav",
            "Windows\system32\config\security.sav",
            "Windows\system32\config\software.sav",
            "Windows\system32\config\system.sav",
            "Windows\system32\inetsrv\config\applicationHost.config",
            "Windows\system32\win.ini",
            "Windows\System32\drivers\etc\hosts"

        )
        Write-Host " `n[*]Searching for sensitive files . . . `n" -fore Yellow        
        foreach ($file in $files){
            searchFile -file $file
        }

    }

}

```

## Semana 5

Durante esta semana se han dado cambios en la estructura final del proyecto, la idea ha cambiado a ser realizado todo mediante el módulo automático.

Dentro del módulo automático se han creado nuevas funciones entre ellas se encuentran: 

- SystemRecon: Esta función es la encargada de realizar un análisis previo para poder reconocer en que tipo de máquina nos encontramos, si es windows X versión, IPs asignadas a la máquina, dominios asignados y usuario actual.
- NetRecon: Esta función es similar a la anterior pero el foco es realizar un análisis de la red, identificando puertos a la escucha en local, conexiones establecidas y un escaner ARP para detectar dispositivos adyacentes en la red.


Para systemRecon se ha echo uso de otras funciones y objetos del sistema accesibles por cualquiera, asi como el objeto ```Win32_NetworkAdapterConfiguration``` que es el encargado de guardar la **configuración** de otros muchos objetos del sistema como servidores DNS, adaptadores de red, MAC del dispositivo etc. Con ```Get-DnsClientServerAddress``` es otra forma de obtener otros objetos relacionados con el **server DNS e IPs asignadas mediante DHCP**.

De esta manera el código actual de las dos funciones:

```

function systemRecon{
        #Función que trata de reconocer la máquina para que el usuario pueda saber en que entorno se encuentra
        try{

            $networkInfo = Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.IPAddress} | Select-Object IPAddress, MacAddress, Description, DNSServerSearchOrder, DHCPServer, DefaultIPGateway, DNSDomain

            $ip = $networkInfo | Select-Object -Expand IPAddress -First 3 | Where-Object { $_ -like '*.*.*.*' } | ForEach-Object ( $_.IPAddress) {
                ForEach-Object{ [IPAddress]$_ } | Where-Object {$_.AddressFamily -eq 'Internetwork' } | ForEach-Object {$_.IPAddressToString}} | Out-String
            $mac = $networkInfo | Select-Object -Expand MacAddress -First 3 | Out-String
            $netAdapter =  $networkInfo | Select-Object -Expand Description -First 3 | Out-String
            $dnsDomain = $networkInfo | Select-Object -Expand DNSDomain -First 2 | Out-String
            $osVersion = (Get-WmiObject -class Win32_OperatingSystem).Caption          
            $userDomain = $env:USERDOMAIN
            $connections = net use
            $netInfo = -join("`nIP:", $ip, "`nNet adapter: ", $netAdapter, "`nDNS domain:", $dnsDomain, "`nUser domain: ", $userDomain)
            $sysInfo = -join("`nOS version:", $osVersion, "`nMAC address:", $mac)

            Write-Host "`n[*]Network info . . ." -ForegroundColor Yellow
            Write-Host $netInfo -ForegroundColor Green
            Write-Host $sysInfo -ForegroundColor Green
            Write-Host $connections -ForegroundColor Green
            Write-Host  (Get-DnsClientServerAddress -AddressFamily IPv4 | Format-Table | Out-String) -ForegroundColor Green

            Start-Sleep -Seconds 3

        }
        catch{
            Write-Error "Recon didn´t work"
        }

    }

    function netRecon {
        Write-Host "`n[*]Searching for nearly devices ARP scan incoming . . .`n" -ForegroundColor Yellow
        
        try{
            
            $nearlyDevices = Get-NetNeighbor -AddressFamily IPv4 | Format-Table ifIndex,IPAddress,LinkLayerAddress,State | Out-String | Select-String "Unreachable" -NotMatch
            if ($nearlyDEvices) {
                Write-Host $nearlyDevices -ForegroundColor Green
            }
            else{
                Write-Host "No hosts up" -ForegroundColor Red
            }

            Start-Sleep 5

            Write-Host "`n[*]Searching for listening ports . . ." -ForegroundColor Yellow
            $Connections = netstat -ano
            $listeningConnections = $Connections | findstr.exe "LISTENING" | Out-String
            $establishedConnections = $Connections | findstr.exe "ESTABLISHED" | Out-String
            if ($listeningConnections) {
                Write-Host $listeningConnections -ForegroundColor Green
            }
            else{
                Write-Host "No listening ports available" -ForegroundColor Red
            }
            
            Write-Host "`n[*]Searching for established connections . . ." -ForegroundColor Yellow
            if ($establishedConnections) {
                Write-Host $establishedConnections -ForegroundColor Green
            }
            else{
                Write-Host "No established ports available" -ForegroundColor Red
            }
            Start-Sleep -Seconds 3
        }
        catch{
            Write-Error "Bad net status"

        }

    }

```

# Semana 6

Esta semana se ha dedicado al debug de las dos funciones, hubo problemas a la hora de realizar el display de ciertas funciones como netstat -ano en este caso se arrojaba un error, este venía dado porque en la variable PATH de windows no estaba configurado el path hacía el directorio **SYSTEM**. A la hora de realizar el ```Format-Table``` se arrojaron errores, la solución fue sencilla ya que no estaba cogiendo el objeto deseado, con cambiarlo al que realmente era se soluciona.

# Semana 7

Durante esta semana se ha dado la finalización de la herramienta se han creado tres nuevas funciones:

- envCreds: Sencilla muestra las variables de entorno para encontrar alguna credencial dentro de estas.
- userEnum: Enumera **grupos y usuarios** dentro del sistema.
- checkFilePerms: Esta función lista los permisos de archivos y directorios en los que se tengan permisos de escritura o ejecución.
